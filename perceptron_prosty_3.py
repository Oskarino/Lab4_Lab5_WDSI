# -*- coding: utf-8 -*-
"""Perceptron prosty 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ViFvkUIme3_ESHILSNtMnbBCp6rYFe03
"""

import numpy as np
import tqdm

def hardlims(input):
  return (input >0 ).astype(float)

def delta_rule(X,Y, weights,n_epochs):
  dims = X.shape[-1]
  for _ in tqdm.tqdm(range(n_epochs)):
    for x,y in zip(X,Y):
      sum = x@weights
      e = y - hardlims(sum)
      # print(e*x)
      weights = weights + e*x
      # print("w", weights, "k")
  return weights

"""#Dane separowalne"""

#AND
n_inputs = 100
n_dims = 3
X = np.random.random((n_inputs, n_dims + 1))
Y = np.random.randint(0,2,size=(n_inputs))
#na 1 wspolrzednej wartosci dodatnie lub ujemne dadza separowalnosc
X[Y== 0] = X[Y== 0] + 100
X[Y== 1] = X[Y== 1] - 100

X[:5]

weights = np.random.random(size=(X.shape[-1]))
print(weights)
print(X@weights)
print(hardlims(X@weights))
print("")

weights = delta_rule(X,Y, weights,n_epochs=10000)

print("Wagi")
print(X@weights)
predictions = hardlims(X@weights)
print(predictions)
print(Y)
print(np.average(np.abs(Y - predictions)))

"""#Dane nieseparowalne"""

#AND
n_inputs = 100
n_dims = 2
X = np.random.random((n_inputs, n_dims + 1))
Y = np.random.randint(0,2,size=(n_inputs))

weights = np.random.random(size=(X.shape[-1]))
print(weights)
print(X@weights)
print(hardlims(X@weights))
print("")

weights = delta_rule(X,Y, weights,n_epochs=10000)

print("Wagi")
print(X@weights)
predictions = hardlims(X@weights)
print(predictions)
print(Y)
print(np.average(np.abs(Y - predictions)))